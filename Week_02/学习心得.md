# 一周刷题总结
此处记录本周学习过程中，在「递归」和「堆」中学习到的知识点和通过作业解决问题而总结出的经验。
---
## 递归
### 通用的模板
1. terminator
2. process current logic
3. drill down
4. reverse states
备注：
1. terminator必须有，否则递归没有尽头。
2. 当process current logic和drill down放在一起写时，表明对当前层的处理直接依赖于下一层的结果，这种情况下题目的逻辑往往比较简单；当process current logic和drill down分开写，即对当前层做一定的处理再回溯，往往会启用一些当前层才具备的变量，它们不跟随递归接口往下走，也可能会更改结果子集。
3. reverse states这一步常出现在「对可能结果做穷举」的题目中，即使用过一个元素后，需要将它剔除后考虑其他元素作为结果的可能性（目前只遇到这类题目用到了回退状态）。
4. 虽然没有在步骤中写，但万不可忘记的一步（对于有返回值的函数来说）：return语句。return的内容是当前层的计算的结果，自底向上来看，每一个递归层得到的结果向上一层反馈，上一层协并下一层的结果继续向上走，如此玩接力游戏返回到第一层，第一层返回的结果即题目的解。
### 难点
1. 最大难点在于找到重复子操作。为了能够找到重复子操作，需要从初始状态走到递归终止状态中历经的状态进行推演，这样走一遍心里会有数，并加深对代码写法的理解。推演过程中不能太着急，一定一步步慢慢走。
2. 第二大难点在于逻辑条件if...else / while语句的确定。通俗来说，也就是什么条件下进行怎样的递归，这一步的确定，需要专注于指定的一层递归空间做仔细的分析，当发生a的时候执行了A，当发生b的时候执行了B，然后再去其他递归层，观察是否可得到类似的信息————这样即通过演绎法归纳出了通用的逻辑。
3. 递归函数中出现的for语句，通常是在对整体条件进行刻画，它确定了要递归的所有情形，此时边界值的确定是关键。
4. java编码实战过程中注意，如果递归结果是一个数组（例如要求返回所有满足条件的结果的集合），那么应当将结果的子集作为函数参数传递（为引用传递），将最终结果定义为全局变量；如果递归结果是一个数，数无法在java中用作引用传递值，故将递归函数的返回值设为数的类型。
### 经典例题的思路分析
##### 从前序和中序遍历中构造二叉树
一开始拿到这题很懵逼，没有一点思路，原因在于没有找到切入口。但一旦告诉了你“运用根结点-左子树-右子树分别在前序遍历和中序遍历中的位置关系”是解决这道题的关键，下面的分析工作反而变得简单了。这道题中，重复子问题，是确定最终结果中的每一棵树的根结点、左子树区间和右子树区间分别在前序遍历和中序遍历中的下标索引，并将当前层的根结点的左指针指向左子树的根结点，其右指针指向右子树的根结点。终止条件有两个，第一个：当传递的左子树或右子树区间不满足区间的要求，即左边界大于右边界，此时返回null；第二个，当左边界等于右边界时，直接返回该索引指向的结点。
##### 全排列1，2
自以为，属于非常经典的套用模板解题的题目，因为它的代码可以用四行注释清晰解释。全排列的两道题目均要求给出所给数字的所有排列情况，不同的是第一道题中给定数字不是重复的，而第二道题中数字有重复出现。两道题相似点在于，其递归终止条件均为当前数组的长度等于所要求的排列的长度，drill down的过程中记得将计数加一、将当前数组更新，同时，开辟一个used数组记录当前哪些元素已经使用过而哪些则没用过（以空间换时间），防止排列中出现雷同的数据。第二道题相比于第一道，不同在于递归终止往结果中加入结果前，需要判重复（除此以外，对于所给的相同的数字，还是应当以不同的数字看待，分别记录其使用情况，因为题目要求中提及，内容相同但排列顺序不同的序列属于两个结果）。
---
---
## 堆
**定义**
满足两个条件的数据结构是堆：1）它是一个完全二叉树；2）对于大跟堆而言，每个结点的值都大于两个孩子结点的值；对于小跟堆而言，每个结点的值都小于两个孩子结点的值。
**各项操作的时间复杂度分析**
（假设是大跟堆）
--|:--:|--:
find-max|O(1)
delete-max|O(logN)
insert|O(logN)
### 难点
1. 对于堆排序时间复杂度的理解：k + nlogk. 其中k表示建立一个k个元素的堆的时间复杂度，nlogk表示n个元素，每个元素都进行插入操作所造成的总共的时间复杂度。
2. heapifyup和heapifydown过程的理解及编码实现。
- heapifyup对应插入元素的过程，即先将待插入元素放在数组的最后，再依次比较其与负结点的大小关系，若（对于维护小跟堆而言）小于父结点的值则下沉，反之则停留在原地不动
- heapifydown对应删除元素，即比较待插入元素与孩子结点的大小关系，若（对于维护小跟堆而言）大于孩子的值则下沉，反之则停留在原地不动
### 经典例题的思路分析
##### 数组中最大的k个元素
- 经典的topK问题，之前面试时被人问过，没回答出来，这里将思路整理一遍。这道题可用的排序算法有多种，除了堆排，快排等也可做，此处只介绍堆排的做法。
- 先写出一个以前一直存在的错误的想法：求topK大元素，就建立小跟堆，求topK小元素，就建立大跟堆。事实上，不论求解哪类问题，建立小根堆和大跟堆都是可以解决的。该方法的时间复杂度为O(n + k * logk)
- 就本题而言，求topK大，倘若采用建立小根堆的方法，则首先拿前k个元素建立大小为k的堆，然后对于k+1到n的元素，每次与堆顶元素进行大小比较，若比堆顶元素大，则作为堆顶元素进堆，进行heapifydown操作。如此遍历完所有数字后，堆顶元素即所求的topK大元素。该方法的时间复杂度为
- 倘若采用建立大根堆的方法，则直接对所有元素建堆，完成后，不断从堆中退出堆顶元素，退出的第k各元素即为所求的topK大元素。该方法的时间复杂度为O(k + (n - k) * logk)